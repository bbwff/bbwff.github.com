---
layout: post
category: 算法
summary: 最近在看算法导论，想记录一个读书笔记之类的东西自己看。就是会记载的很乱，写的很随意，自己看，反正这个博客也不会公开，hhhh。
title: 算法导论学习笔记
date: 2016-11-28 09:29:00
tags:  algorithm
---

{% include JB/setup %}


**Overview**

{{ page.summary }}


## 第二章-算法入门

算法这种东西，有些思想是比较简单的，最好是把算法写成代码实现。

第二章在讲算法设计这里，讲了一个分治法，就是把大化小，也就是递归那种，最后在合并，在排序里面就是递归归并排序，代码里面有一个小细节，就是哨兵。在归并排序里面哨兵就是会放在要归并的数组的最后位置，一般是一个无穷大，如果是升序，就设置正无穷，降序就设置为负无穷，这样的话，就不用判断归并时候两个数组到底是不是非空了。代码比较简洁，算是代码实现的小技巧了。

<!--more-->

下面是我写的分治法排序的代码，是递归归并排序。

```
package Introduction2Algorithms.chapter2;
import java.io.Console;
/**
 * Created by bbw on 2016/11/28.
 */
//采用递归也就是分治法
public class mergeSort {
 static    void merge(int [] a,int p,int q, int r){
        int l1=q-p+1;
        int l2=r-q;
        int[]a1=new int[l1+1];
        int[]a2=new int[l2+1];
        for (int i=0;i<l1;i++){
            a1[i]=a[p+i];
        }
        //此处是一个哨兵，无穷大的
        a1[l1]=Integer.MAX_VALUE;
        for (int i=0;i<l2;i++){
            a2[i]=a[q+1+i];
        }
        //此处是一个哨兵，无穷大的
        a2[l2]=Integer.MAX_VALUE;

        int i1=0;
        int i2=0;

//此处出现过bug，就是我把i从0开始了，应该是从p开始
        for (int i=p;i<=r;i++){
            if (a1[i1]<a2[i2]) {
                a[i] = a1[i1];
                i1++;
            }
            else {
                a[i] = a2[i2];
                i2++;
            }
        }
    }

    static void mergeSort(int[]a,int p,int q){

        if (p<q){
            int t=(p+q)/2;
            mergeSort(a,p,t);
            mergeSort(a,t+1,q);
            merge(a,p,t,q);
        }
    }

    public static void main(String[] args)
    {
        int[] x = { 6, 2, 4, 1, 5, 9 };
        mergeSort(x,0,x.length-1);
        for (int i:x){
            System.out.println(i);
        }
    }
}
```

这个代码挺简单的，但是我居然中间出了bug，就是数组的边界没搞好，导致数据混乱。这里面的哨兵比较方便，但就只是浪费了一个空间，代价不大，代码比较简洁。

再说下怎么算时间复杂度，因为每个mergeSort都是拆成两个一半数量级的mergeSort加一个merge。merge的时间复杂度是Cn.

所以T(n)=2T(n/2)+cn。

然后一般这种时间复杂度就是按照递归拆开，可以拆成logN层。然后每一层都有一个cn，拆logN次就有 CnLogN，然后  那个 logN.T(1)就被舍去，时间复杂度就是O(nlogN)。具体类似递归时间复杂度计算方法看[这个网页](http://blog.csdn.net/xiaoxian8023/article/details/8134260)。
然后算法导论第二章留了一道习题，是用归并排序的思想求一个数组的逆序对的数目。在归并排序的过程中，整个过程递归到底就是先对两个只有一个的数组进行归并，然后再对归并之后归并，其实就是二路归并。然后我们只要在merge的时候计算是否前面数组的树大于后面数组的数，用一个全局变量来记录所有出现的次数就是逆序对的个数。









